<?xml version="1.0" encoding="UTF-8"?><record_update table="sp_widget">
    <sp_widget action="INSERT_OR_UPDATE">
        <category>custom</category>
        <client_script><![CDATA[function($scope, $rootScope, $location, FmContainers) {
  /* widget controller */
  var c = this;
  c.formInitialized = false;
  c.deregisterUIActionListener = null;

  c.setCurrentSectionTo = FmContainers.setCurrentSectionTo;
  c.getCurrentSection = FmContainers.getCurrentSection;
  c.isFirstSection = FmContainers.isFirstSection;
  c.isLastSection = FmContainers.isLastSection;
  //c.isLastSection = FmContainers.isLastSection;
  
	$scope.$on('spModel.gForm.initialized', function(e, g_form) {
    debugger;
		c.g_form = g_form;
    FmContainers.init(c.data.sc_cat_item._sections);
    c.formInitialized = true;
  });
  
  c.submit = function() {
    console.log(getPrimaryAction().action_name);
    c.g_form.submit(getPrimaryAction().action_name);
    deregisterUIActionListener = $rootScope.$on("spModel.uiActionComplete", successHandler);
  }

  function getPrimaryAction() {
    var primaryActions = $scope.data.form._ui_actions.filter(function(action) {
      return action.primary;
    });		
    return (primaryActions.length) ? primaryActions[0] : null;
  }

  function successHandler(e, result) {
    deregisterUIActionListener();
    navigateToSuccessPage();
  }

  function navigateToSuccessPage() {
    $location.search({
      //'id': c.options.success_page || $location.search().id,
      'id': 'ticket',
      'table': 'incident',
      'sys_id': '1c741bd70b2322007518478d83673af3'
      //'table': c.options.table || $location.search().table,
      //'sys_id': $location.search().sys_id
    });
  }
}]]></client_script>
        <controller_as>c</controller_as>
        <css>// Loading spinner
.fm-loading {
  height: 100%;
  min-height: 400px;
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: space-around;

  svg {
    width: 150px;
    height: 150px;
  }
}</css>
        <data_table>sp_instance</data_table>
        <demo_data/>
        <description/>
        <docs/>
        <field_list/>
        <has_preview>true</has_preview>
        <id>modded-form</id>
        <internal>false</internal>
        <link/>
        <name>modded-form</name>
        <option_schema>[{"name":"table","section":"other","label":"table","type":"string"},{"name":"view","section":"other","label":"view","type":"string"},{"name":"record","section":"other","label":"record","type":"string"}]</option_schema>
        <public>false</public>
        <roles/>
        <script><![CDATA[/*(function() {
  data.view = options.view || $sp.getParameter('view');
	data.sysId = options.record || $sp.getParameter('sys_id') || '-1';
	data.table = options.table || $sp.getParameter('table');
	//data.form = $sp.getForm(data.table, data.sysId, '', data.view);
})();*/
// populate the 'data' variable with catalog item, variables, and variable view
// populate the 'data' variable with catalog item, variables, and variable view
(function() {
	var embeddedWidgetOptions = ['auto_redirect', 'requested_for_id', 'requested_for_display'];
	if (input && input.action == 'init_item') {
		data._generatedItemGUID = gs.generateGUID();
		return;
	}
	else if (input && input.action === "order_one_step") {
		
	}
	else if (input && input.action === "order_item") {
		//Minimum set of widget options supported for Embedded widget
		embeddedWidgetOptions.forEach(function (embeddedWidgetOption) {
			if (typeof input[embeddedWidgetOption] != 'undefined')
				options[embeddedWidgetOption] = input[embeddedWidgetOption];
		});
		data.orderItemModal = $sp.getWidget('widget-modal', {
			embeddedWidgetId: 'sc-checkout', 
			embeddedWidgetOptions: {
				cart: {name: input.cart}, 
				action: 'order_now', 
				item: input.itemDetails, 
																																requested_for: {id:options.requested_for_id, displayValue:options.requested_for_display},
																																auto_redirect: options.auto_redirect,
																																parentParams: input.workspaceParams
			}, 
			backdrop: 'static', 
			keyboard: false, 
			size: 'md'
		});
		return;
	} else if (input && input.action == "order_wishlist_item") {
		//Minimum set of widget options supported for Embedded widget
		embeddedWidgetOptions.forEach(function (embeddedWidgetOption) {
			if (typeof input[embeddedWidgetOption] != 'undefined')
				options[embeddedWidgetOption] = input[embeddedWidgetOption];
		});
		data.orderItemModal = $sp.getWidget('widget-modal', {
			embeddedWidgetId: 'sc-checkout', 
			embeddedWidgetOptions: {
				cart: {name: input.cart}, 
				action: 'order_now_wishlisted_item', 
				item: input.itemDetails, 
																																	requested_for: {id:options.requested_for_id, displayValue:options.requested_for_display},
																																	auto_redirect: options.auto_redirect,
																																	parentParams: input.workspaceParams
			}, 
			backdrop: 'static', 
			keyboard: false, 
			size: 'md'
		});
		return;
	} else if (input && input.action === 'log_request') {
		 $sp.logStat('Cat Item Request', input.itemDetails.sys_class_name, input.itemDetails.sys_id, input.itemDetails.name);
		 return;
	}
	
	// portal can specify a catalog and catalog category home page
	data.sc_catalog_page = $sp.getDisplayValue("sc_catalog_page") || "sc_home";
	data.sc_category_page = $sp.getDisplayValue("sc_category_page") || "sc_category";
	data.sc_catalog = $sp.getDisplayValue('sc_catalog');
	var edit_parm = $sp.getParameter('edit');
	data.is_cart_item = edit_parm == 'cart';
	data.is_wishlist_item = edit_parm == 'wishlist';
	data.show_wishlist_msg = false;
	data.recordFound = true;
	var catalogID = $sp.getValue('sc_catalog');

	options.show_add_cart_button = (options.show_add_cart_button == "true");

	/*var clGenerator = new GlideChoiceList();
	var choiceListQuantity = clGenerator.getChoiceList("sc_cart_item", "quantity");
	var choicelistQuantityData = [];
	for (var i = 0; i < choiceListQuantity.size(); i++) {
		var choice = choiceListQuantity.get(i);
		if (!isNaN(choice.getValue()))
			choicelistQuantityData.push({value : parseInt(choice.getValue()), label : choice.getLabel()});
	}

	data.choiceListQuantity = choicelistQuantityData;
	data.quantity = choicelistQuantityData[0].value;*/

	if (options.page) {
		var pageGR = new GlideRecord("sp_page");
		options.page = (pageGR.get(options.page)) ? pageGR.getValue("id") : null;
	}

	if (options.table) {
		var tableGR = new GlideRecord("sys_db_object");
		options.table = (tableGR.get(options.table)) ? tableGR.getValue("name") : null;
	}
	options.url = options.url || "id={page}&is_new_order=true&table={table}&sys_id={sys_id}";
	

	data.showPrices = $sp.showCatalogPrices();
	var m = data.msgs = {};
	m.submitMsg = gs.getMessage("Submit");
	m.orderNowMsg = gs.getMessage("Order Now");
	m.submittedMsg = gs.getMessage("Submitted");
	m.createdMsg = gs.getMessage("Created");
	m.trackMsg = gs.getMessage("track using 'Requests' in the header or");
	m.clickMsg = gs.getMessage("click here to view");
	m.dialogTitle = gs.getMessage("Delete Attachment");
	m.dialogMessage = gs.getMessage("Are you sure?");
	m.dialogOK = gs.getMessage("OK");
	m.dialogCancel = gs.getMessage("Cancel");
	
	m.renameSuccessMsg = gs.getMessage("Attachment renamed successfully");
	m.deleteSuccessMsg = gs.getMessage("Attachment deleted successfully");
	m.wishlistMsg = gs.getMessage('Wish List');
	m.cartMsg = gs.getMessage('Cart');
	m.itemWishlistMsg = gs.getMessage('This item is already in your Wish List. If you attempt to add this item to your Wish List it will overwrite the existing item.');
	m.invalidRecordMsg = gs.getMessage('You are either not authorized or record is not valid.');
	m.wishlistUpdateMsg = gs.getMessage('Your Wish List has been updated.');
	m.wishlistAddMsg = gs.getMessage('Your item has been added to your Wish List.');
	m.cartAddMsg = gs.getMessage('Your item has been added to your Cart. To make changes to the items in your cart, click ');
	m.viewWishListMsg = gs.getMessage('View Wish List');
	m.viewCartMsg = gs.getMessage('View Cart');
	m.delete_attachment = gs.getMessage("Delete Attachment?");

	data.maxAttachmentSize = parseInt(gs.getProperty("com.glide.attachment.max_size", 1024));
	if (isNaN(data.maxAttachmentSize))
		data.maxAttachmentSize = 24;
	m.largeAttachmentMsg = gs.getMessage("Attached files must be smaller than {0} - please try again", "" + data.maxAttachmentSize + "MB");
	
	var cartName = data.is_cart_item ? 'DEFAULT' : 'saved_items';
	var cart = new sn_sc.CartJS(cartName);

	data.showWishlist = new sn_sc.Catalog('' + catalogID).isWishlistEnabled();

	if (edit_parm) {
		var cart_item_id = $sp.getParameter("sys_id");
		var gr = new GlideRecord("sc_cart_item");
		if (!gr.get(cart_item_id) || gr.cart != cart.getCartID()) {
			data.recordFound = false;
			return;
		}
		var catItemData = {};
		catItemData.sys_id = gr.getValue('cat_item');
		catItemData.cart_item_id = gr.getUniqueValue();
		catItemData.table = "sc_cart_item";
		catItemData.is_ordering = true;

		data.sc_cat_item = $sp.getCatalogItem(catItemData);
		console.log(data.sc_cat_item);
		data.sc_cat_item.isCartItem = true;
		data.sc_cat_item.cart_guide = gr.getValue('order_guide');
		var values = getValues(cart_item_id);

		for(var f in data.sc_cat_item._fields) {
			// Put the values into the cat item fields
			var field = data.sc_cat_item._fields[f];
			if (typeof values[f] != "undefined" && typeof values[f].value != "undefined") {
				if (values[f].type == 9 || values[f].type == 10)
					field.value = values[f].displayValue;
				else if (values[f].type == 25)
					field.value = values[f].decrypted_value;
				else
					field.value = values[f].value;
				field.displayValue = values[f].displayValue;
				field.display_value_list = values[f].display_value_list;
			}
			updatePriceOnField(field);
				
		}
		data._generatedItemGUID = cart_item_id;
		data.quantity = '' + gr.quantity;
	} else {
	
		if (input)
			data.sys_id = input.sys_id;
		else if (options.sys_id)
			data.sys_id = options.sys_id;
		else
			data.sys_id = $sp.getParameter("sys_id") || $sp.getParameter('sl_sys_id');
	
		if (!data.sys_id) {
			data.recordFound = false;
			return;
		}
	
		data._generatedItemGUID = gs.generateGUID();
		var validatedItem = new sn_sc.CatItem('' + data.sys_id);
		if (!validatedItem.canView() || !validatedItem.isVisibleServicePortal()) {
			data.recordFound = false;
			return;
		}
	
		data.sc_cat_item = $sp.getCatalogItem(data.sys_id, true);
		data.hideDeliveryTime = (options.hide_delivery_time == "true" || data.sc_cat_item.sys_class_name == 'sc_cat_item_producer' || data.sc_cat_item.sys_class_name == 'sc_cat_item_guide' || data.sc_cat_item.sys_class_name == 'std_change_record_producer');
		if (data.sc_cat_item.category) {
			var categoryJS;
			var categoryID = validatedItem.getFirstAccessibleCategoryForSearch(catalogID);
			if ($sp.getParameter("sysparm_category")) {
				categoryJS = new sn_sc.CatCategory($sp.getParameter("sysparm_category") + "");
				categoryID = $sp.getParameter("sysparm_category") + "";
			}
			else {
				categoryJS = new sn_sc.CatCategory(categoryID);
			}
			
			data.category = {
				name: categoryJS.getTitle(),
				url: categoryJS.canView() ? '?id=' + data.sc_category_page + '&sys_id=' + categoryID : "#"
			}
			data.categories = [];
			if (categoryJS && GlideStringUtil.isEligibleSysID(categoryJS.getID()))
				data.categories.push({
					label: categoryJS.getTitle(),
					url: categoryJS.canView() ? '?id=' + data.sc_category_page + '&sys_id=' + categoryID : "#"
				});
			while(categoryJS && categoryJS.getParent()) {
				var parentId =  categoryJS.getParent();
				categoryJS = new sn_sc.CatCategory(parentId);
				var category = {
					label: categoryJS.getTitle(),
					url: categoryJS.canView() ? '?id=' + data.sc_category_page + '&sys_id=' + parentId : "#"
				};
				data.categories.unshift(category);
			}
		}
		var gr = new GlideRecord('sc_cart_item');
		gr.addQuery('cart', cart.getCartID());
		gr.addQuery('cat_item', data.sys_id);
		gr.query();
		if (gr.next() && !options.isServiceWorkspace)
			data.show_wishlist_msg = true;
	}

	data.sys_properties = {
		twostep: gs.getProperty("glide.sc.sp.twostep", "true") == 'true'
	};

	var athTblName = 'sc_cart_item';
	var className = data.sc_cat_item.sys_class_name;
	if (!new global.CatalogItemTypeProcessor().canCreateNormalCartItem(className)) {
		if (className == 'sc_cat_item_producer' || className == 'std_change_record_producer') {
				var gr = new GlideRecord(className);
				gr.get(data.sc_cat_item.sys_id);
				if (gr.isValidRecord())
					athTblName = gr.getValue('table_name');
		}
	}
	data._attachmentTable = athTblName;

	data.stdChg = {};
	if (className === 'std_change_record_producer') {
		//Populate scope with the porperty for two step
		data.stdChg.twoStep = false;
		var twoStepProp = new global.StdChangeUtils().getValue('two_step') + '';
		if (twoStepProp)
			data.stdChg.twoStep = twoStepProp === '1';

		var stdChgProducerGr = new GlideRecord('std_change_record_producer');
		stdChgProducerGr.get(data.sc_cat_item.sys_id);
		if (stdChgProducerGr.isValidRecord())
			data.stdChg.currentVersion = stdChgProducerGr.getValue('current_version');
	}
	
	$sp.logStat('Cat Item View', data.sc_cat_item.sys_class_name, data.sc_cat_item.sys_id, data.sc_cat_item.name);
	
	function getValues(sys_id) {
		var qs = new sn_sc.VariablePoolQuestionSetJS();
		qs.setCartID(sys_id);
		qs.load();
		var values = {};
		var questions = qs.getFlatQuestions();
		for (var i = 0; i < questions.length; i++) {
			var qKey = questions[i].name;
			if (typeof qKey == 'undefined' || qKey == '')
				qKey = "IO:" + questions[i].sys_id;
			values[qKey] = questions[i];
		}
		return values;
	}

	function setPrice(field, p, rp) {
		if (p != undefined)
			field.price = p;
		if (rp != undefined)
			field.recurring_price = rp;
	}

	function updatePriceForReferenceTable(field) {
		var tableName = field.refTable + '';
		if (tableName != undefined && tableName != null && tableName != '') {
			var gr = new GlideRecord(tableName);
			if (gr.isValid()) {
				if (gr.get(field.value) && gr.isValidRecord()) {
					updatePrice(gr, field);
					updateRecurringPrice(gr, field);
				}
			}
		}
	}

	function updatePriceForListCollector(field) {
		var tableName = field.refTable + '';
		if (tableName != undefined && tableName != null && tableName != '') {
			var gr = new GlideRecord(tableName);
			if (gr.isValid()) {
				var values = field.value.split(',');
				gr.addQuery('sys_id', values);
				gr.query();
				var p = 0.0;
				var rp = 0.0;
				var price_value_list = [];
				while(gr.next()) {
						var price_field = {};
						updatePrice(gr, price_field);
						updateRecurringPrice(gr, price_field);
						if (price_field.price)
							p += Number(price_field.price);
						else
							price_field.price = 0.0;
						if (price_field.recurring_price)
							rp += Number(price_field.recurring_price);
						else
							price_field.recurring_price = 0.0;
						price_value_list.push(price_field);
				}
				field.price = p;
				field.recurring_price = rp;
				field.price_value_list = price_value_list;
			}
		}
	}

	function updatePrice(gr, field) {
		if (gr.isValidField('price'))
			field.price = gr.getValue('price');
		else if (gr.isValidField('u_price'))
			field.price = gr.getValue('u_price');
	}

	function updateRecurringPrice(gr, field) {
		if (gr.isValidField('recurring_price'))
			field.recurring_price = gr.getValue('recurring_price');
		else if (gr.isValidField('u_recurring_price'))
			field.recurring_price = gr.getValue('u_recurring_price');
	}

	function updatePriceOnField(field) {
		if (field.type == 'boolean' || field.type == 'boolean_confirm') {
			if (field.value == 'true' || field.value == true)
				setPrice(field, field._pricing.price_if_checked, field._pricing.recurring_price_if_checked);
			else
				setPrice(field, 0, 0);
		} else if (field.choices) {
			field.choices.forEach( function(choice) {
				if (choice.value +'' == field.value + '')
					 setPrice(field, choice.price, choice.recurring_price);
			});
		} else if (field._pricing && field._pricing.pricing_implications === true) {
			if (field.type == 'reference') 
				updatePriceForReferenceTable(field);
			else if (field.type == 'glide_list')
				updatePriceForListCollector(field);
		}
	}
})()]]></script>
        <servicenow>false</servicenow>
        <sys_class_name>sp_widget</sys_class_name>
        <sys_created_by>james.tandy@snc</sys_created_by>
        <sys_created_on>2018-10-16 02:34:11</sys_created_on>
        <sys_id>516673a7db81a300a8e68a8b3a961988</sys_id>
        <sys_mod_count>56</sys_mod_count>
        <sys_name>modded-form</sys_name>
        <sys_package display_value="formmods" source="x_snc_formmods">c94633a3db81a300a8e68a8b3a961980</sys_package>
        <sys_policy/>
        <sys_scope display_value="formmods">c94633a3db81a300a8e68a8b3a961980</sys_scope>
        <sys_update_name>sp_widget_516673a7db81a300a8e68a8b3a961988</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2018-10-17 04:14:20</sys_updated_on>
        <template><![CDATA[<div>
  <!-- Loading spinner -->
  <div class="fm-loading" ng-if="!c.formInitialized">
    <svg width="44" height="44" viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg" stroke="#000">
      <g fill="none" fill-rule="evenodd" stroke-width="2">
        <circle cx="22" cy="22" r="1">
          <animate attributeName="r" begin="0s" dur="1.8s" values="1; 20" calcMode="spline" keyTimes="0; 1" keySplines="0.165, 0.84, 0.44, 1" repeatCount="indefinite"/>
          <animate attributeName="stroke-opacity" begin="0s" dur="1.8s" values="1; 0" calcMode="spline" keyTimes="0; 1" keySplines="0.3, 0.61, 0.355, 1" repeatCount="indefinite"/>
        </circle>
        <circle cx="22" cy="22" r="1">
          <animate attributeName="r" begin="-0.9s" dur="1.8s" values="1; 20" calcMode="spline" keyTimes="0; 1" keySplines="0.165, 0.84, 0.44, 1" repeatCount="indefinite"/>
          <animate attributeName="stroke-opacity" begin="-0.9s" dur="1.8s" values="1; 0" calcMode="spline" keyTimes="0; 1" keySplines="0.3, 0.61, 0.355, 1" repeatCount="indefinite"/>
        </circle>
      </g>
    </svg>
  </div>
	<sp-model form-model="::c.data.sc_cat_item"
            mandatory="true"
            template-url="fm-form"
            ng-if="::c.data.sc_cat_item"></sp-model>
  <div class="container-fluid" ng-if="c.formInitialized">
    <button class="btn default" ng-show="!c.isFirstSection()" ng-click="c.setCurrentSectionTo(c.getCurrentSection() - 1)">Back</button>
    <button class="btn default" ng-show="!c.isLastSection()" ng-click="c.setCurrentSectionTo(c.getCurrentSection() + 1)">Next</button>
    <button class="btn success" ng-show="true" ng-click="c.submit()">Submit</button>
  </div>
</div>]]></template>
    </sp_widget>
</record_update>
